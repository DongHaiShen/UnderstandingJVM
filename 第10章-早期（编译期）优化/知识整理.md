[TOC]

## 10.2 Javac 编译器

### 10.2.1 编译过程

1. 从Sun Javac 的代码来看，编译过程大致可以分为3个过程，分别是：
    + 解析与填充符号表过程。
    + 插入式注解处理器的注解处理过程。
    + 分析与字节码生成过程。

![编译过程](http://ww1.sinaimg.cn/large/d8e93840ly1g1f4ks2sg6j20s104mtav.jpg)

### 10.2.2 解析与填充符号表
+ 解析步骤包括了经典程序编译原理中的词法分析和语法分析两个过程。

#### 10.2.2.1 词法、语法分析
1. 词法分析是将**源代码的字符流转变为标记（Token）集合**，单个字符是程序编写过程的最小元素，而标记则是编译过程的最小元素，关键字、变量名、字面量、运算符都可以成为标记
2. 语法分析是根据 **Token 序列构造抽象语法树**的过程，抽象语法树（Abstract Syntax Tree，AST）是一种用来描述程序代码语法结构的树形表示方式，语法树的每一个节点都代表着程序代码中的一个语法结构（Construct），例如包、类型、修饰符、运算符、接口、返回值甚至代码注释等都可以是一个语法结构。
3. 经过语法分析之后，编译器就基本不会再对源码文件进行操作了，后续的操作都建立在抽象语法树之上。

#### 10.2.2.2 填充符号表
1. 完成了语法分析和词法分析之后，下一步就是填充符号表的过程。
2. 符号表（Symbol Table）是由一组符号地址和符号信息构成的表格，可以把它想象成哈希表中 K-V 值对的形式（实际上符号表不一定是哈希表实现，可以是有序符号表、树状符号表、栈结构符号表等）。符号表中所登记的信息在编译的不同阶段都要用到。
3. 在语义分析中，符号表所登记的内容将用于语义检查（如检查一个名字的使用和原先的说明是否一致）和产生中间代码。在目标代码生成阶段，当对符号名进行地址分配时，符号表是地址分配的依据。

### 10.2.3 注解处理器
1. 在 JDK1.5 之后，Java 语言提供了对注解（Annotation）的支持，这些注解与普通的 Java 代码一样，是在运行期间发挥作用的。
2. 在 JDK1.6 中提供了一组插入式注解处理器的标准API，在编译期间对注解进行处理，我们可以把它看做是一组编译器的插件。在这些插件里面，可以读取、修改、添加抽象语法树中的任意元素
3. 如果这些插件在处理注解期间对语法树进行了修改，编译器将回到解析及填充符号表的过程重新处理，直到所有插入式注解处理器都没有再对语法树进行修改为止，每一次循环称为一个Round。

### 10.2.4 语义分析与字节码生成
+ 语法分析之后，编译器获得了程序代码的抽象语法树表示，语法树能表示一个结构正确的源程序的抽象，**但无法保证源程序是符合逻辑的**。而语义分析的主要任务是对结构上正确的源程序进行上下文有关性质的审查。Javac 的编译过程中，语义分析过程分为**标注检查**以及**数据及控制流分析**两个步骤

#### 10.2.4.1 标注检查

1. 标注检查步骤检查的内容包括诸如变量使用前是否已被声明、变量与赋值之间的数据类型是否能够匹配等。
2. 在标注检查步骤中，还有一个重要的动作称为**常量折叠**

#### 10.2.4.2 数据及控制流分析

1. 数据及控制流分析是对程序上下文逻辑更进一步的验证，它可以检查出诸如程序局部变量在使用前是否有赋值、方法的每条路径是否都有返回值、是否所有的受查异常都被正确处理了等问题。
2. 编译时期的数据及控制流分析与类加载时的数据及控制流分析的目的基本上是一致的，但校验范围有所区别，有一些校验项只有在编译期或运行期才能进行。

#### 10.2.4.3 解语法糖
1. 语法糖（Syntactic Sugar），也称糖衣语法，指在计算机语言中添加的某种语法，这种语法对语言的功能并没有影响，但是更方便程序员使用。通常来说，**使用语法糖能够增加程序的可读性**，从而减少程序代码出错的机会。
2. Java 中最常用的语法糖主要是前面提到过的**泛型**、**变长参数、自动装箱/拆箱**等
3. 但虚拟机运行时不支持这些语法，它们**在编译阶段还原回简单的基础语法结构**，这个过程称为**解语法糖**。

#### 10.2.4.4 字节码生成
1. 字节码生成是 Javac 编译过程的最后一个阶段，字节码生成阶段不仅仅是把前面各个步骤所生成的信息（语法树、符号表）转化成字节码写到磁盘中，编译器还进行了少量的代码添加和转换工作。
2. **实例构造器 `<init>()` 方法和类构造器 `<clinit>()` 方法就是在这个阶段添加到语法树之中的**。
3. 这两个构造器的产生过程实际上是一个**代码收敛**的过程，编译器会把如下操作收敛到 `<init>()` 和 `<clinit>()` 方法之中，并且保证一定是按**先执行父类的实例构造器，然后初始化变量，最后执行语句块**的顺序进行：
    + 语句块（对于实例构造器而言是 “{}” 块，对于类构造器而言是 “static{}” 块）
    + 变量初始化（实例变量和类变量）
    + 调用父类的实例构造器等操作

4. 完成了对语法树的遍历和调整之后，再把填充了所有所需信息的符号表转成字节码，生成最终的 Class 文件，到此为止整个编译过程宣告结束。

## 10.3 Java语法糖的味道

### 10.3.1 泛型与类型擦除
1. 泛型是 JDK1.5 的一项新增特性，它的本质是**参数化类型**（Parametersized Type）的应用，也就是说**所操作的数据类型被指定为一个参数**。这种参数类型可以用在类、接口和方法的创建中，分别称为泛型类、泛型接口和泛型方法。
2. Java 语言中的泛型**只在程序源码中存在**，在编译后的字节码文件中，就已经**替换为原来的原生类型**（Raw Type，也称为裸类型）了，并且在相应的地方插入了强制转型代码，因此，对于运行期的 Java 语言来说，`ArrayList<int>` 与 `ArrayList<String>` 就是同一个类
3. 所以泛型技术实际上是 Java 语言的一颗语法糖，Java语言中的泛型实现方法称为**类型擦除**，基于这种方法实现的泛型称为**伪泛型**。

```java
public class GenericTypes
{
    // 'method(List<String>)' clashes with 'method(List<Integer>)'; both methods have same erasure
    // 编译错误，因为类型擦除后参数类型相同，都是 List<E>

    public static void method(List<String> list)
    {
        System.out.println("invoke method(List<String> list)");
    }

    public static void method(List<Integer> list)
    {
        System.out.println("invoke method(List<Integer> list)");
    }
}
```

4. 上述这段代码是**不能被编译**的，因为参数 `List<Integer>` 和 `List<String>` 编译之后都被擦除了，变成了一样的原生类型 `List<E>`，擦除动作导致这两种方法的特征签名变得一模一样。


### 10.3.2 自动装箱、拆箱与遍历循环
1. 从纯技术的角度来讲，自动装箱、自动拆箱与遍历循环（Foreach循环）这些语法糖，无论是实现上还是思想上都不能和泛型相比，两者的难度和深度都有很大差距。但是毫无疑问，它们是 Java 语言里使用得最多的语法糖。

2. 自动装箱、拆箱与遍历循环
```java
// 编译前
public static void main(String[] args) 
{
	List<Integer> list = Arrays.asList(1, 2, 3, 4);
	
	int sum = 0;
	for (int i : list) {
		sum += i;
	}
	System.out.println(sum);
}
```

```java
// 编译后
public static void main(String[] args) 
{
	List list = Arrays.asList( new Integer[] {
		 Integer.valueOf(1),
		 Integer.valueOf(2),
		 Integer.valueOf(3),
		 Integer.valueOf(4) });

	int sum = 0;
	for (Iterator localIterator = list.iterator(); localIterator.hasNext(); ) {
		int i = ((Integer)localIterator.next()).intValue();
		sum += i;
	}
	System.out.println(sum);
}
```

3. 上述代码包含了泛型、自动装箱、自动拆箱、遍历循环与变长参数 5 种语法糖，以及它们在编译后的变化：
    + 泛型擦除已经说过。
    + 自动装箱、拆箱在编译之后被转化成了对应的包装和还原方法
    + 遍历循环把代码还原成了**迭代器的实现**，**这也是为何遍历循环需要被遍历的类实现Iterable接口的原因**。
    + 变长参数在调用的时候变成了一个**数组类型的参数**，在变长参数出现之前，程序员就是使用数组来完成类似功能的。
      































