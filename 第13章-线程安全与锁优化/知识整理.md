[TOC]

## 13.2 线程安全

+ 《Java Concurrency In Practice》对 “线程安全” 有一个比较恰当的定义：“当多个线程访问一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那这个对象是线程安全的”。

### 13.2.1 Java 语言中的线程安全

+ 按照线程安全的 “安全程度” 由强至弱来排序，我们可以将 Java 语言中各种操作共享的数据分为以下5类：
    + 不可变
    + 绝对线程安全
    + 相对线程安全
    + 线程兼容
    + 线程对立

#### 13.2.1.1 不可变

1. 在 Java 语言中（特指 JDK1.5 以后，即 Java 内存模型被修正之后的 Java 语言），不可变（Immutable）的对象一定是线程安全的，无论是对象的方法实现还是方法的调用者，都不需要再采取任何的线程安全保障措施，“不可变” 带来的安全性是最简单和最纯粹的。
2. 如果共享数据是一个**基本数据类型**，那么只要在定义时使用 **final** 关键字修饰它就可以保证它是不可变的。
3. 如果共享数据是一个**对象**，那就需要保证**对象的行为不会对其状态产生任何影响**才行，其中最简单的就是把对象中带有状态的变量都声明为 final，这样在构造函数结束之后，它就是不可变的，例如 Integer 类

#### 13.2.1.2 绝对线程安全

1. 绝对的线程安全完全满足上述给出的线程安全的定义，这个定义其实是很严格的，一个类要达到 “不管运行时环境如何，调用者都不需要任何额外的同步措施” 通常需要付出很大的，甚至有时候是不切实际的代价。在 JavaAPI 中标注自己是线程安全的类，大多数都不是绝对的线程安全。

2. 在如下代码中，尽管这里使用到的 Vector 的 `get()` 、`remove()` 和 `size()` 方法都是同步的，但是在多线程的环境中，如果不在方法调用端做额外的同步措施的话，使用这段代码仍然是不安全的，因为如果另一个线程恰好在错误的时间里删除了一个元素，导致序号 i 已经不再可用的话，再用 i 访问数组就会抛出异常。

```java
public class VectorTest
{
    private static Vector<Integer> vector = new Vector<Integer>();

    public static void main(String[] args)
    {
        while (true)
        {
            for (int i = 0; i < 10; i++)
            {
                vector.add(i);
            }

            Thread removeThread = new Thread(new Runnable()
            {
                @Override
                public void run()
                {
                    for (int i = 0; i < vector.size(); i++)
                    {
                        vector.remove(i);
                    }
                }
            });

            Thread printThread = new Thread(new Runnable()
            {
                @Override
                public void run()
                {
                    for (int i = 0; i < vector.size(); i++)
                    {
                        System.out.println((vector.get(i)));
                    }
                }
            });

            removeThread.start();
            printThread.start();

            //不要同时产生过多的线程，否则会导致操作系统假死
            while (Thread.activeCount() > 20);
        }
    }
}
```

#### 13.2.1.3 相对线程安全

1. 相对的线程安全就是我们通常意义上所讲的线程安全，它需要保证对这个对象**单独的操作是线程安全**的，我们在调用的时候不需要做额外的保障措施，但是对于一些特定顺序的连续调用，就可能需要在调用端使用额外的同步手段来保证调用的正确性。
2. 在 Java 语言中，大部分的**线程安全类**都属于这种类型，例如Vector、HashTable、Collections的synchronizedCollection() 方法包装的集合等。

#### 13.2.1.4 线程兼容

1. 线程兼容是指对象**本身并不是线程安全的**，但是可以通过在调用端正确地使用同步手段来保证对象在并发环境中可以安全地使用。我们平常说一个类不是线程安全的，绝大多数时候指的是这一种情况。
2. JavaAPI 中大部分的类都是属于线程兼容的，如 ArrayList 和 HashMap 等。

#### 13.2.1.5 线程对立
1. 线程对立是指无论调用端是否采取了同步措施，都无法在多线程环境中并发使用的代码。由于 Java 语言天生就具备多线程特性，线程对立这种排斥多线程的代码是很少出现的，而且通常都是有害的，应当尽量避免。
2. 一个线程对立的例子是 Thread 类的 `suspend()` 和 `resume()` 方法，如果有两个线程同时持有一个线程对象，一个尝试去中断线程，另一个尝试去恢复线程，如果并发进行的话，无论调用时是否进行了同步，目标线程都是存在死锁风险的。
3. 如果 `suspend()` 中断的线程就是即将要执行 `resume()` 的那个线程，那就肯定要产生死锁了。


### 13.2.2 线程安全的实现方法

#### 13.2.2.1 互斥同步

1. 互斥同步（Mutual Exclusion & Synchronization）是常见的一种并发正确性保障手段。
2. **同步**是指在多个线程并发访问共享数据时，保证共享数据在同一个时刻只被一个（或者是一些，使用信号量的时候）线程使用。
3. **互斥是实现同步的一种手段**，临界区（Critical Section）、互斥量（Mutex）和信号量（Semaphore）都是主要的互斥实现方式。
4. 因此，在这4个字里面，互斥是因，同步是果；互斥是方法，同步是目的。
5. 在 Java 中，最基本的互斥同步手段就是 synchronized 关键字：
    + synchronized 关键字经过编译之后，会在同步块的前后分别形成 monitorenter 和 monitorexit 这两个字节码指令
    + 这两个字节码都需要一个 **reference 类型的参数来指明要锁定和解锁的对象**。
    + 如果 Java 程序中的 synchronized 明确指定了对象参数，那就是这个对象的reference（如同步块）
    + 如果没有明确指定，那就根据 synchronized 修饰的是**实例方法还是类方法**，去取对应的**对象实例或 Class 对象**来作为锁对象。
6. 根据虚拟机规范的要求，在执行monitorenter指令时，首先要尝试获取对象的锁：
    + 如果这个对象没被锁定，或者当前线程已经拥有了那个对象的锁（**同一线程可重入**），把锁的计数器加1
    + 相应的，在执行 monitorexit 指令时会将锁计数器减1
    + 当计数器为 0 时，锁就被释放
    + 如果获取对象锁失败，那当前线程就要阻塞等待，直到对象锁被另外一个线程释放为止。
7. 在虚拟机规范对 monitorenter 和 monitorexit 的行为描述中，有两点是需要特别注意的：
    + 首先，synchronized 同步块**对同一条线程来说是可重入的**，不会出现自己把自己锁死的问题。
    + 其次，同步块在已进入的线程执行完之前，会阻塞后面其他线程的进入。
8. 除了 synchronized 之外，我们还可以使用 java.util.concurrent 包中的**重入锁**（ReentrantLock）来实现同步，在基本用法上，ReentrantLock 与synchronized很相似，不过，ReentrantLock 增加了一些高级功能，主要有以下3项：
    + 等待可中断：当持有锁的线程长期不释放锁的时候，正在等待的线程**可以选择放弃等待**
    + 可实现公平锁：公平锁是指多个线程在等待同一个锁时，**必须按照申请锁的时间顺序来依次获得锁**；而非公平锁则不保证这一点，在锁被释放时，任何一个等待锁的线程都有机会获得锁。
    + 锁可以绑定多个条件：锁绑定多个条件是指一个 ReentrantLock 对象可以同时绑定多个 Condition 对象，而在synchronized中，锁对象的 `wait()` 和 `notify()` 或 `notifyAll()` 方法可以实现一个隐含的条件，如果要和多于一个的条件关联的时候，就不得不额外地添加一个锁

#### 13.2.2.2 非阻塞同步
1. 互斥同步最主要的问题就是进行线程阻塞和唤醒所带来的性能问题，因此这种同步也称为阻塞同步（Blocking Synchronization）。
2. 从处理问题的方式上说，互斥同步属于一种**悲观**的并发策略，总是认为只要不去做正确的同步措施（例如加锁），那就肯定会出现问题。
3. 而另外一个选择是：**基于冲突检测的乐观并发策略**，通俗地说，就是先进行操作：
    + 如果没有其他线程争用共享数据，那操作就成功了；
    + 如果共享数据有争用，产生了冲突，那就再采取其他的补偿措施（最常见的补偿措施就是不断地重试，直到成功为止）
4. 这种乐观的并发策略的许多实现都不需要把线程挂起，因此这种同步操作称为非阻塞同步（Non-Blocking Synchronization）。
5. 然而在这里我们需要操作和冲突检测这两个步骤具备原子性，如果这里再使用互斥同步来保证就失去意义了，所以我们只能靠硬件来完成这件事情，硬件保证一个**从语义上看起来需要多次操作的行为只通过一条处理器指令就能完成**，这类指令常用的有：
    + 测试并设置（Test-and-Set）
    + 获取并增加（Fetch-and-Increment）
    + 交换（Swap）
    + 比较并交换（Compare-and-Swap，即**CAS**）
    + 加载链接/条件存储（Load-Linked/Store-Conditional，即 LL/SC）
6. 其中 CAS 指令需要有3个操作数，分别是：
    + 内存位置（在 Java 中可以简单理解为变量的内存地址，用 V 表示）
    + 旧的预期值（用A表示）
    + 新值（用B表示）
7. CAS 指令执行时，**当且仅当 V 符合旧预期值 A 时，处理器用新值 B 更新 V 的值**，否则它就不执行更新。但是无论是否更新了 V 的值，都会返回 V 的旧值，上述的处理过程是一个原子操作。

#### 13.2.2.3 无同步方案
1. 要保证线程安全，并不是一定就要进行同步，两者没有因果关系。同步只是保证共享数据争用时的正确性的手段，如果一个方法本来就不涉及共享数据，那它自然就无须任何同步措施去保证正确性，因此会有一些代码**天生就是线程安全的**：
    + **可重入代码**（Reentrant Code）：这种代码也叫做纯代码（Pure Code），可以在代码执行的任何时刻中断它，转而去执行另外一段代码（包括递归调用它本身），而在控制权返回后，原来的程序不会出现任何错误。
    + **线程本地存储**（Thread Local Storage）：如果一段代码中所需要的数据必须与其他代码共享，那就看看这些共享数据的代码是否能保证在同一个线程中执行？如果能保证，我们就可以把共享数据的可见范围限制在同一个线程之内，这样，无须同步也能保证线程之间不出现数据争用的问题。



## 13.3 锁优化

### 13.3.1 自旋锁与自适应自旋

1. 互斥同步对性能最大的影响是阻塞的实现，挂起线程和恢复线程的操作都需要转入内核态中完成，这些操作给系统的并发性能带来了很大的压力。
2. 然而共享数据的锁定状态只会持续很短的一段时间，为了这段时间去挂起和恢复线程并不值得。如果物理机器能让两个或以上的线程同时并行执行，我们就可以让后面请求锁的那个线程 “**稍等一下**”，但不放弃处理器的执行时间，看看持有锁的线程是否很快就会释放锁。为了让线程等待，我们只需让线程执行一个**忙循环**（自旋），这项技术就是所谓的**自旋锁**。
3. 自旋等待本身虽然避免了线程切换的开销，但它是要占用处理器时间的。因此，如果锁被占用的时间很短，自旋等待的效果就会非常好，反之，如果锁被占用的时间很长，那么自旋的线程只会白白消耗处理器资源。
4. 在 JDK1.6 中引入了**自适应**的自旋锁。**自适应意味着自旋的时间不再固定了，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定**：
    + 如果在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也很有可能再次成功，进而它将允许自旋等待**持续相对更长的时间**，比如100个循环。
    + 另外，如果对于某个锁，自旋很少成功获得过，那在以后要获取这个锁时将可能**省略掉自旋过程**，以避免浪费处理器资源。

### 13.3.2 锁消除

1. 锁消除是指虚拟机即时编译器在运行时，对一些代码上要求同步，但是被检测到不可能存在共享数据竞争的锁进行消除。
2. 锁消除的主要判定依据来源于**逃逸分析**的数据支持，如果判断在一段代码中，堆上的所有数据都不会逃逸出去从而被其他线程访问到，那就可以把它们当做栈上数据对待，认为它们是线程私有的，同步加锁自然就无须进行。
3. 变量是否逃逸，对于虚拟机来说需要使用数据流分析来确定，但是程序员自己应该是很清楚的，怎么会在明知道不存在数据争用的情况下要求同步呢？答案是**有许多同步措施并不是程序员自己加入的**，同步的代码在 Java 程序中的普遍程度很高。

4. 在如下代码中，无论是源码字面上还是程序语义上都没有同步：
```java
public String concatString (String s1, String s2, String s3)
{
	return sl + s2 + s3;
}
```

5. 但是由于 String 是一个不可变的类，对字符串的连接操作总是通过生成新的 String 对象来进行的，因此 Javac编译器会对 String 连接做自动优化。在 JDK1.5 之前，会转化为 StringBuffer 对象的连续 `append()` 操作，在 JDK1.5 及以后的版本中，会转化为 StringBuilder 对象的连续 `append()` 操作，代码如下：

```java
public String concatString (String s1, String s2, string s3)
{
	StringBuffer sb = new StringBuffer(); 
    
    // lock
	sb.append(s1);
    // unlock
    
    // lock
	sb.append(s2);
    // unlock
    
    // lock
	sb.append(s3);
    // unlock
    
	return sb.toString();
}
```

6. 每个 `StringBuffer.append()` 方法中都有一个同步块，锁就是 sb 对象。虚拟机观察变量 sb，很快就会发现它的动态作用域被限制在 `concatString()` 方法内部。也就是说，sb 的所有引用永远不会 “逃逸” 到该方法之外，其他线程无法访问到它。因此，虽然这里有锁，但是可以被安全地消除掉，在即时编译之后，这段代码就会忽略掉所有的同步而直接执行了。


### 13.3.3 锁粗化
1. 原则上，我们在编写代码的时候，总是**推荐将同步块的作用范围限制得尽量小**——只在共享数据的实际作用域中才进行同步，这样是为了使得需要同步的操作数量尽可能变小，如果存在锁竞争，那等待锁的线程也能尽快拿到锁。
2. 大部分情况下，上面的原则都是正确的，但是如果**一系列的连续操作都对同一个对象反复加锁和解锁**，甚至加锁操作是出现在循环体中的，那即使没有线程竞争，频繁地进行互斥同步操作也会导致不必要的性能损耗。
3. 下列代码中**连续的 `append()` 方法**就属于这类情况。如果虚拟机探测到有这样一串零碎的操作都对同一个对象加锁，将会把**加锁同步的范围扩展（粗化）到整个操作序列的外部**。以下列代码为例，就是扩展到第一个`append()` 操作之前直至最后一个 `append()` 操作之后，这样只需要加锁一次就可以了。

```java
public String concatString (String s1, String s2, string s3)
{
	StringBuffer sb = new StringBuffer(); 
    
    // lock
	sb.append(s1); 
	sb.append(s2); 
	sb.append(s3); 
    // unlock
	
    return sb.toString();
}
```

### 13.3.4 轻量级锁

1. 轻量级锁是 JDK1.6 之中加入的新型锁机制，它名字中的 “轻量级” 是相对于使用操作系统互斥量来实现的传统锁而言的，因此传统的锁机制就称为 “重量级” 锁。
2. 首先需要强调一点的是，轻量级锁并不是用来代替重量级锁的，它的本意是**在没有多线程竞争的前提下**，减少传统的重量级锁使用操作系统互斥量产生的性能消耗。
3. HotSpot 虚拟机的对象头（Object Header）分为两部分信息：
    + 第一部分用于存储**对象自身的运行时数据**，如哈希码、GC分代年龄等，官方称它为 “**Mark Word**”，它是实现轻量级锁和偏向锁的关键。
    + 另外一部分用于存储**指向方法区对象类型数据的指针**，如果是数组对象的话，还会有一个额外的部分用于存储数组长度。

![Mark Word](http://ww1.sinaimg.cn/mw690/d8e93840ly1g1h8y3jam8j20tt07d41l.jpg)

4. 在代码进入同步块的时候，如果此同步对象没有被锁定（锁标志位为 “01” 状态），虚拟机首先将在**当前线程的栈帧中**建立一个名为**锁记录**（Lock Record）的空间，用于存储锁对象目前的 **Mark Word的拷贝**（官方把这份拷贝加了一个Displaced前缀，即Displaced Mark Word），这时候线程堆栈与对象头的状态如下：

![轻量级锁CAS之前](http://ww1.sinaimg.cn/mw690/d8e93840ly1g1h8zy6xyej20ge08bjsc.jpg)

5. 然后，虚拟机将**使用 CAS 操作尝试将对象的 Mark Word 更新为指向 Lock Record 的指针**：
    + 如果这个更新动作成功了，那么这个线程就拥有了该对象的锁，并且对象Mark Word的锁标志位（Mark Word的最后2bit）将转变为 “00”，即表示此对象处于轻量级锁定状态。
    + 如果这个更新操作失败了，虚拟机首先会检查对象的 Mark Word **是否指向当前线程的栈帧** ：
        + 如果是说明当前线程已经拥有了这个对象的锁，那就可以直接进入同步块继续执行；
        + 否则说明这个锁对象已经被其他线程抢占了。如果有两条以上的线程争用同一个锁，那轻量级锁就不再有效，**要膨胀为重量级锁**，锁标志的状态值变为 “10”

### 13.3.5 偏向锁
1. 偏向锁也是 JDK1.6 中引入的一项锁优化，它的目的是**消除数据在无竞争情况下的同步原语**，进一步提高程序的运行性能。如果说轻量级锁是在无竞争的情况下使用 CAS 操作去消除同步使用的互斥量，那偏向锁就是**在无竞争的情况下把整个同步都消除掉**，连 CAS 操作都不做了。
2. 偏向锁的意思是这个锁**会偏向于第一个获得它的线程**，如果在接下来的执行过程中，该锁没有被其他的线程获取，**则持有偏向锁的线程将永远不需要再进行同步**。
3. 当锁对象**第一次被线程获取**的时候：
    + 虚拟机将会把对象头中的标志位设为 “01”，即偏向模式；
    + 同时使用 CAS 操作把获取到这个锁的线程的 ID 记录在对象的Mark Word之中：
        + 如果CAS操作成功，持有偏向锁的线程以后每次进人这个锁相关的同步块时，虚拟机都可以不再进行任何同步操作
        + 当有另外一个线程去尝试获取这个锁时，偏向模式就宣告结束。根据锁对象目前是否处于被锁定的状态，撤销偏向（Revoke Bias）后恢复到未锁定（标志位为 “01”）或轻量级锁定（标志位为 “00”）的状态，后续的同步操作就如上面介绍的轻量级锁那样执行。

![锁状态转换](http://ww1.sinaimg.cn/large/d8e93840ly1g1h9ayf0clj20s60e7aeu.jpg)

































